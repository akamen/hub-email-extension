/*******************************************************************************
 * Copyright (C) 2016 Black Duck Software, Inc.
 * http://www.blackducksoftware.com/
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *******************************************************************************/
package com.blackducksoftware.integration.email.batch.processor;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.StringUtils;

import com.blackducksoftware.integration.hub.api.component.version.ComponentVersion;
import com.blackducksoftware.integration.hub.api.item.MetaService;
import com.blackducksoftware.integration.hub.api.vulnerability.SeverityEnum;
import com.blackducksoftware.integration.hub.api.vulnerability.VulnerabilityItem;
import com.blackducksoftware.integration.hub.api.vulnerability.VulnerabilityRequestService;
import com.blackducksoftware.integration.hub.dataservice.notification.item.VulnerabilityContentItem;
import com.blackducksoftware.integration.hub.exception.HubIntegrationException;
import com.blackducksoftware.integration.hub.notification.processor.ItemEntry;
import com.blackducksoftware.integration.hub.notification.processor.ItemTypeEnum;
import com.blackducksoftware.integration.hub.notification.processor.MapProcessorCache;
import com.blackducksoftware.integration.hub.notification.processor.NotificationCategoryEnum;
import com.blackducksoftware.integration.hub.notification.processor.event.VulnerabilityEvent;
import com.blackducksoftware.integration.hub.service.HubRequestService;

public class VulnerabilityCache extends MapProcessorCache<VulnerabilityEvent> {

    private final HubRequestService hubRequestService;

    private final VulnerabilityRequestService vulnerabilityRequestService;

    private final MetaService metaService;

    public VulnerabilityCache(HubRequestService hubRequestService, VulnerabilityRequestService vulnerabilityRequestService, MetaService metaService) {
        this.hubRequestService = hubRequestService;
        this.vulnerabilityRequestService = vulnerabilityRequestService;
        this.metaService = metaService;

    }

    @Override
    public void addEvent(final VulnerabilityEvent event) {
        final String key = event.getEventKey();
        if (!hasEvent(key)) {
            getEventMap().put(key, event);
        } else {
            final VulnerabilityEvent storedEvent = getEventMap().get(key);
            final Set<ItemEntry> storedEventDataMap = storedEvent.getDataSet();
            final Set<ItemEntry> eventDataMap = event.getDataSet();
            storedEventDataMap.addAll(eventDataMap);
            if (!event.getVulnerabilityIdSet().isEmpty()) {
                storedEvent.getVulnerabilityIdSet().addAll(event.getVulnerabilityIdSet());
            }
        }
    }

    @Override
    public void removeEvent(final VulnerabilityEvent event) {
        final String key = event.getEventKey();
        if (getEventMap().containsKey(key)) {
            final VulnerabilityEvent storedEvent = getEventMap().get(key);
            if (!storedEvent.getVulnerabilityIdSet().isEmpty() && !event.getVulnerabilityIdSet().isEmpty()) {
                storedEvent.getVulnerabilityIdSet().removeAll(event.getVulnerabilityIdSet());
            }

            if (storedEvent.getVulnerabilityIdSet().isEmpty()) {
                removeEvent(key);
            }
        }
    }

    @Override
    public Collection<VulnerabilityEvent> getEvents() throws HubIntegrationException {
        final Collection<VulnerabilityEvent> vulnerabilities = super.getEvents();
        // need to group the vulnerabilities by severity which can be gathered by the vulnerability API.
        final Collection<VulnerabilityEvent> result = new LinkedList<>();
        for (final VulnerabilityEvent event : vulnerabilities) {
            final List<VulnerabilityEvent> vulnerabilityEvents = createVulnerabilityEvents(event);
            for (final VulnerabilityEvent vulnerability : vulnerabilityEvents) {
                result.add(vulnerability);
            }
        }

        return result;
    }

    private List<VulnerabilityEvent> createVulnerabilityEvents(final VulnerabilityEvent originalEvent) throws HubIntegrationException {
        final List<VulnerabilityEvent> eventList = new LinkedList<>();
        final VulnerabilityContentItem vulnerabilityContent = originalEvent.getNotificationContent();
        final String vulnerabilityUrl = findVulnerabilityUrl(vulnerabilityContent.getComponentVersionUrl());
        final List<VulnerabilityItem> vulnerabilityList = createVulnerabilityItemList(vulnerabilityUrl);
        addEventsToList(originalEvent, vulnerabilityList, eventList);
        addCountsToDataSet(eventList);
        return eventList;
    }

    private String findVulnerabilityUrl(String componentVersionUrl) throws HubIntegrationException {
        String url = null;
        final ComponentVersion compVersion = hubRequestService.getItem(componentVersionUrl, ComponentVersion.class);
        url = metaService.getLink(compVersion, MetaService.VULNERABILITIES_LINK);
        return url;
    }

    private List<VulnerabilityItem> createVulnerabilityItemList(String vulnerabilityUrl) throws HubIntegrationException {
        List<VulnerabilityItem> itemList = Collections.emptyList();
        if (!StringUtils.isBlank(vulnerabilityUrl)) {
            itemList = vulnerabilityRequestService.getComponentVersionVulnerabilities(vulnerabilityUrl);
        }
        return itemList;
    }

    private void addEventsToList(VulnerabilityEvent originalEvent, List<VulnerabilityItem> vulnerabilityList, List<VulnerabilityEvent> eventList) {
        final Map<NotificationCategoryEnum, VulnerabilityEvent> eventMap = new HashMap<>();
        for (final String vulnId : originalEvent.getVulnerabilityIdSet()) {
            for (final VulnerabilityItem vulnerability : vulnerabilityList) {
                final NotificationCategoryEnum eventCategory = getEventCategory(vulnerability.getSeverity());
                final String vulnName = vulnerability.getVulnerabilityName();
                if (vulnId.equals(vulnName)) {
                    if (eventMap.containsKey(eventCategory)) {
                        final VulnerabilityEvent event = eventMap.get(eventCategory);
                        event.getVulnerabilityIdSet().add(vulnName);
                    } else {

                        final Set<String> vulnset = new HashSet<>();
                        vulnset.add(vulnName);
                        final VulnerabilityEvent event = new VulnerabilityEvent(eventCategory,
                                originalEvent.getNotificationContent(),
                                vulnset);
                        eventMap.put(eventCategory, event);
                        eventList.add(event);
                    }
                }
            }
        }
    }

    private NotificationCategoryEnum getEventCategory(final String severityString) {
        final SeverityEnum severity = SeverityEnum.getSeverityEnum(severityString);

        switch (severity) {
        case HIGH: {
            return NotificationCategoryEnum.HIGH_VULNERABILITY;
        }
        case MEDIUM: {
            return NotificationCategoryEnum.MEDIUM_VULNERABILITY;
        }
        case LOW: {
            return NotificationCategoryEnum.LOW_VULNERABILITY;
        }
        default: {
            return NotificationCategoryEnum.VULNERABILITY;
        }
        }
    }

    private void addCountsToDataSet(List<VulnerabilityEvent> eventList) {
        for (final VulnerabilityEvent event : eventList) {
            final int size = event.getVulnerabilityIdSet().size();
            if (size > 1) {
                event.getDataSet().add(new ItemEntry(ItemTypeEnum.COUNT.name(), String.valueOf(size)));
            }
        }
    }
}
