package com.blackducksoftware.integration.email.batch.processor;

import java.net.URISyntaxException;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.blackducksoftware.integration.hub.api.notification.VulnerabilitySourceQualifiedId;
import com.blackducksoftware.integration.hub.dataservices.notification.items.NotificationContentItem;
import com.blackducksoftware.integration.hub.dataservices.notification.items.VulnerabilityContentItem;

public class VulnerabilityProcessor extends NotificationSubProcessor<VulnerabilityEvent> {
    private final Logger logger = LoggerFactory.getLogger(VulnerabilityProcessor.class);

    public VulnerabilityProcessor(final SubProcessorCache<VulnerabilityEvent> cache) {
        super(cache);
    }

    @Override
    public void process(final NotificationContentItem notification) {
        if (notification instanceof VulnerabilityContentItem) {
            final VulnerabilityContentItem vulnerabilityContentItem = (VulnerabilityContentItem) notification;
            handleNotification(vulnerabilityContentItem);
        }
    }

    private void handleNotification(final VulnerabilityContentItem vulnerabilityContentItem) {
        try {
            final List<VulnerabilitySourceQualifiedId> addedVulnList = vulnerabilityContentItem.getAddedVulnList();
            final List<VulnerabilitySourceQualifiedId> updatedVulnList = vulnerabilityContentItem.getUpdatedVulnList();
            final List<VulnerabilitySourceQualifiedId> deletedVulnList = vulnerabilityContentItem.getDeletedVulnList();

            if (addedVulnList != null && !addedVulnList.isEmpty()) {
                getCache().addEvent(createEvent(ProcessingAction.ADD, vulnerabilityContentItem, getVulnerabilityIds(addedVulnList)));
            }

            if (updatedVulnList != null && !updatedVulnList.isEmpty()) {
                getCache().addEvent(createEvent(ProcessingAction.ADD, vulnerabilityContentItem, getVulnerabilityIds(updatedVulnList)));
            }

            if (deletedVulnList != null && !deletedVulnList.isEmpty()) {
                getCache().removeEvent(createEvent(ProcessingAction.REMOVE, vulnerabilityContentItem, getVulnerabilityIds(deletedVulnList)));
            }
        } catch (URISyntaxException e) {
            logger.error("Error processing vulnerability item {} ", vulnerabilityContentItem, e);
        }
    }

    private VulnerabilityEvent createEvent(final ProcessingAction action, VulnerabilityContentItem vulnerabilityContent,
            final Set<String> vulnerabilityIdList) throws URISyntaxException {

        return new VulnerabilityEvent(action, NotificationCategoryEnum.VULNERABILITY, vulnerabilityContent, vulnerabilityIdList);
    }

    private Set<String> getVulnerabilityIds(final List<VulnerabilitySourceQualifiedId> itemList) {
        final Set<String> set = new HashSet<>();
        for (final VulnerabilitySourceQualifiedId item : itemList) {
            set.add(item.getVulnerabilityId());
        }

        return set;
    }
}
