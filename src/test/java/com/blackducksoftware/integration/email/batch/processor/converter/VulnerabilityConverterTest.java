package com.blackducksoftware.integration.email.batch.processor.converter;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.net.URISyntaxException;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

import org.junit.Test;

import com.blackducksoftware.integration.email.batch.processor.NotificationCategoryEnum;
import com.blackducksoftware.integration.email.batch.processor.NotificationEvent;
import com.blackducksoftware.integration.email.batch.processor.ItemTypeEnum;
import com.blackducksoftware.integration.email.batch.processor.ProcessingAction;
import com.blackducksoftware.integration.email.model.batch.ItemEntry;
import com.blackducksoftware.integration.hub.api.notification.VulnerabilitySourceQualifiedId;
import com.blackducksoftware.integration.hub.api.project.ProjectVersion;
import com.blackducksoftware.integration.hub.dataservices.DataServicesFactory;
import com.blackducksoftware.integration.hub.dataservices.notification.items.VulnerabilityContentItem;

public class VulnerabilityConverterTest {

	private static final String VERSION = "Version";
	private static final String COMPONENT = "Component";
	private static final String PROJECT_VERSION_NAME = "ProjectVersionName";
	private static final String PROJECT_NAME = "ProjectName";

	private VulnerabilityContentItem createNotification(final String projectName, final String projectVersionName,
			final String componentName, final String componentVersion, final List<VulnerabilitySourceQualifiedId> added,
			final List<VulnerabilitySourceQualifiedId> updated, final List<VulnerabilitySourceQualifiedId> deleted)
			throws URISyntaxException {

		final ProjectVersion projectVersion = new ProjectVersion();
		projectVersion.setProjectName(projectName);
		projectVersion.setProjectVersionName(projectVersionName);
		final UUID componentId = UUID.randomUUID();
		final UUID componentVersionId = UUID.randomUUID();
		final String componentVersionUrl = "http://localhost/api/components/" + componentId + "/versions/"
				+ componentVersionId;
		final VulnerabilityContentItem item = new VulnerabilityContentItem(new Date(), projectVersion, componentName,
				componentVersion, componentVersionUrl, added, updated, deleted);
		return item;
	}

	@Test
	public void testNewVulnerabilities() throws Exception {
		final List<VulnerabilitySourceQualifiedId> vulnerabilities = new LinkedList<>();
		vulnerabilities.add(new VulnerabilitySourceQualifiedId("vuln_source", "vuln_id"));
		final VulnerabilityContentItem vulnerability = createNotification(PROJECT_NAME, PROJECT_VERSION_NAME, COMPONENT,
				VERSION, vulnerabilities, Collections.emptyList(), Collections.emptyList());

		final VulnerabilityConverter converter = new VulnerabilityConverter(new DataServicesFactory(null));
		final List<NotificationEvent> eventList = converter.convert(vulnerability);
		assertEquals(1, eventList.size());
		for (final NotificationEvent event : eventList) {
			assertEquals(ProcessingAction.ADD, event.getAction());
			assertEquals(PROJECT_NAME, event.getProjectName());
			assertEquals(PROJECT_VERSION_NAME, event.getProjectVersion());
			assertEquals(NotificationCategoryEnum.VULNERABILITY, event.getCategoryType());
			assertFalse(event.getVulnerabilityIdSet().isEmpty());
			final Set<ItemEntry> dataSet = event.getDataSet();
			final ItemEntry componentKey = new ItemEntry(ItemTypeEnum.COMPONENT.name(), COMPONENT);
			assertTrue(dataSet.contains(componentKey));

			final ItemEntry versionKey = new ItemEntry("", VERSION);
			assertTrue(dataSet.contains(versionKey));
			for (final VulnerabilitySourceQualifiedId vulnId : vulnerabilities) {
				assertTrue(event.getVulnerabilityIdSet().contains(vulnId.getVulnerabilityId()));
			}
		}
	}

	@Test
	public void testUpdatedVulnerabilities() throws Exception {
		final List<VulnerabilitySourceQualifiedId> vulnerabilities = new LinkedList<>();
		vulnerabilities.add(new VulnerabilitySourceQualifiedId("vuln_source", "vuln_id"));
		final VulnerabilityContentItem vulnerability = createNotification(PROJECT_NAME, PROJECT_VERSION_NAME, COMPONENT,
				VERSION, Collections.emptyList(), vulnerabilities, Collections.emptyList());

		final VulnerabilityConverter converter = new VulnerabilityConverter(new DataServicesFactory(null));
		final List<NotificationEvent> eventList = converter.convert(vulnerability);
		assertEquals(1, eventList.size());
		for (final NotificationEvent event : eventList) {
			assertEquals(ProcessingAction.ADD, event.getAction());
			assertEquals(PROJECT_NAME, event.getProjectName());
			assertEquals(PROJECT_VERSION_NAME, event.getProjectVersion());
			assertEquals(NotificationCategoryEnum.VULNERABILITY, event.getCategoryType());
			assertFalse(event.getVulnerabilityIdSet().isEmpty());
			final Set<ItemEntry> dataSet = event.getDataSet();
			final ItemEntry componentKey = new ItemEntry(ItemTypeEnum.COMPONENT.name(), COMPONENT);
			assertTrue(dataSet.contains(componentKey));

			final ItemEntry versionKey = new ItemEntry("", VERSION);
			assertTrue(dataSet.contains(versionKey));
			for (final VulnerabilitySourceQualifiedId vulnId : vulnerabilities) {
				assertTrue(event.getVulnerabilityIdSet().contains(vulnId.getVulnerabilityId()));
			}
		}
	}

	@Test
	public void testDeletedVulnerabilities() throws Exception {
		final List<VulnerabilitySourceQualifiedId> vulnerabilities = new LinkedList<>();
		vulnerabilities.add(new VulnerabilitySourceQualifiedId("vuln_source", "vuln_id"));
		final VulnerabilityContentItem vulnerability = createNotification(PROJECT_NAME, PROJECT_VERSION_NAME, COMPONENT,
				VERSION, Collections.emptyList(), Collections.emptyList(), vulnerabilities);

		final VulnerabilityConverter converter = new VulnerabilityConverter(new DataServicesFactory(null));
		final List<NotificationEvent> eventList = converter.convert(vulnerability);
		assertEquals(1, eventList.size());
		for (final NotificationEvent event : eventList) {
			assertEquals(ProcessingAction.REMOVE, event.getAction());
			assertEquals(PROJECT_NAME, event.getProjectName());
			assertEquals(PROJECT_VERSION_NAME, event.getProjectVersion());
			assertEquals(NotificationCategoryEnum.VULNERABILITY, event.getCategoryType());
			assertFalse(event.getVulnerabilityIdSet().isEmpty());
			final Set<ItemEntry> dataSet = event.getDataSet();
			final ItemEntry componentKey = new ItemEntry(ItemTypeEnum.COMPONENT.name(), COMPONENT);
			assertTrue(dataSet.contains(componentKey));

			final ItemEntry versionKey = new ItemEntry("", VERSION);
			assertTrue(dataSet.contains(versionKey));
			for (final VulnerabilitySourceQualifiedId vulnId : vulnerabilities) {
				assertTrue(event.getVulnerabilityIdSet().contains(vulnId.getVulnerabilityId()));
			}
		}
	}

	@Test
	public void testNewAndDeletedVulnerabilities() throws Exception {
		final List<VulnerabilitySourceQualifiedId> vulnerabilities = new LinkedList<>();
		vulnerabilities.add(new VulnerabilitySourceQualifiedId("vuln_source", "vuln_id"));
		final VulnerabilityContentItem vulnerability = createNotification(PROJECT_NAME, PROJECT_VERSION_NAME, COMPONENT,
				VERSION, vulnerabilities, Collections.emptyList(), vulnerabilities);

		final VulnerabilityConverter converter = new VulnerabilityConverter(new DataServicesFactory(null));
		final List<NotificationEvent> eventList = converter.convert(vulnerability);
		assertEquals(2, eventList.size());
		final Map<ProcessingAction, Integer> eventActionMap = new HashMap<>();
		for (final NotificationEvent event : eventList) {
			final ProcessingAction action = event.getAction();
			if (!eventActionMap.containsKey(action)) {
				eventActionMap.put(action, new Integer(1));
			} else {
				Integer count = eventActionMap.get(action);
				int temp = count.intValue();
				temp++;
				count = new Integer(temp);
			}
			assertEquals(PROJECT_NAME, event.getProjectName());
			assertEquals(PROJECT_VERSION_NAME, event.getProjectVersion());
			assertEquals(NotificationCategoryEnum.VULNERABILITY, event.getCategoryType());
			assertFalse(event.getVulnerabilityIdSet().isEmpty());
			final Set<ItemEntry> dataSet = event.getDataSet();
			final ItemEntry componentKey = new ItemEntry(ItemTypeEnum.COMPONENT.name(), COMPONENT);
			assertTrue(dataSet.contains(componentKey));

			final ItemEntry versionKey = new ItemEntry("", VERSION);
			assertTrue(dataSet.contains(versionKey));
			for (final VulnerabilitySourceQualifiedId vulnId : vulnerabilities) {
				assertTrue(event.getVulnerabilityIdSet().contains(vulnId.getVulnerabilityId()));
			}
		}
		assertEquals(1, eventActionMap.get(ProcessingAction.ADD).intValue());
		assertEquals(1, eventActionMap.get(ProcessingAction.REMOVE).intValue());
	}

	@Test
	public void testNewUpdateDeletedVulnerabilities() throws Exception {
		final List<VulnerabilitySourceQualifiedId> vulnerabilities = new LinkedList<>();
		vulnerabilities.add(new VulnerabilitySourceQualifiedId("vuln_source", "vuln_id"));
		final VulnerabilityContentItem vulnerability = createNotification(PROJECT_NAME, PROJECT_VERSION_NAME, COMPONENT,
				VERSION, vulnerabilities, vulnerabilities, vulnerabilities);

		final VulnerabilityConverter converter = new VulnerabilityConverter(new DataServicesFactory(null));
		final List<NotificationEvent> eventList = converter.convert(vulnerability);
		assertEquals(3, eventList.size());
		final Map<ProcessingAction, Integer> eventActionMap = new HashMap<>();
		for (final NotificationEvent event : eventList) {
			final ProcessingAction action = event.getAction();
			Integer count;
			if (!eventActionMap.containsKey(action)) {
				count = new Integer(1);
			} else {
				count = eventActionMap.get(action);
				int temp = count.intValue();
				temp++;
				count = new Integer(temp);
			}
			eventActionMap.put(action, count);
			assertEquals(PROJECT_NAME, event.getProjectName());
			assertEquals(PROJECT_VERSION_NAME, event.getProjectVersion());
			assertEquals(NotificationCategoryEnum.VULNERABILITY, event.getCategoryType());
			assertFalse(event.getVulnerabilityIdSet().isEmpty());
			final Set<ItemEntry> dataSet = event.getDataSet();
			final ItemEntry componentKey = new ItemEntry(ItemTypeEnum.COMPONENT.name(), COMPONENT);
			assertTrue(dataSet.contains(componentKey));

			final ItemEntry versionKey = new ItemEntry("", VERSION);
			assertTrue(dataSet.contains(versionKey));
			for (final VulnerabilitySourceQualifiedId vulnId : vulnerabilities) {
				assertTrue(event.getVulnerabilityIdSet().contains(vulnId.getVulnerabilityId()));
			}
		}
		assertEquals(2, eventActionMap.get(ProcessingAction.ADD).intValue());
		assertEquals(1, eventActionMap.get(ProcessingAction.REMOVE).intValue());
	}
}
